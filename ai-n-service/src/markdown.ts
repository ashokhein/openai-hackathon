//@ts-nocheck
import { remark } from 'remark';
import remarkParse from 'remark-parse';

//Generated By ChatGPT
export const adfToMarkdown = (adfNode: any): string => {
    let markdown = '';

    if (Array.isArray(adfNode.content)) {
        adfNode.content.forEach((childNode: any) => {
            const childMarkdown = adfToMarkdown(childNode);
            if (childMarkdown) {
                markdown += childMarkdown;
            }
        });
    }

     switch (adfNode.type) {
        case 'doc':
            // Remove double empty lines.
            return markdown.replace(/\n{3,}/g, '\n\n');
        case 'heading':
            return `${'#'.repeat(adfNode.attrs.level)} ${markdown}\n\n`;
        case 'paragraph':
            return `${markdown}\n\n`;
        case 'date':
            return `${new Date(adfNode.attrs.timestamp - 1000).toLocaleDateString()}`;
        case 'bulletList':
            return `${markdown}\n`;
        case 'orderedList':
            return `${markdown}\n`;
        case 'listItem':
            return `- ${markdown}`;
        case 'strong':
            return `**${markdown}**`;
        case 'em':
            return `*${markdown}*`;
        case 'strike':
            return `~~${markdown}~~`;
        case 'underline':
            return `<u>${markdown}</u>`;
        case 'text':
            return adfNode.text;
        case 'table':
            return `${markdown}\n`;
        case 'tableRow':
            // Ignore empty rows.
            return markdown.trim() ? `${markdown}|\n` : '';
        case 'tableCell':
            // Ignore empty cells.
            return markdown.trim() ? `| ${markdown} ` : '';
        case 'tableHeader':
            // Ignore empty header cells.
            return markdown.trim() ? `| ${markdown} ` : '';
        case 'codeBlock':
            return `\n\`\`\`${adfNode?.attrs?.language || 'shell'}\n${markdown}\n\`\`\`\n\n`;
        case 'mention': 
            return `${adfNode?.attrs?.text}`;
        case 'inlineCode':
            return `\`${markdown}\``;
        case 'blockquote':
            return `> ${markdown}\n\n`;
        case 'hardBreak':
            return '  \n';
        case 'rule':
            return '---\n\n';
        case 'panel':
            return `*${adfNode.attrs.panelType.toUpperCase()}* ${markdown}\n\n`;
        case 'status':
            return `*${adfNode.attrs.text.toUpperCase()}*\n\n`;
        case 'inlineCard':
            // Custom representation for inlineCard using hyperlink
            const url = adfNode.attrs.url;
            return url ? `[${url}](${url})` : '';
        case 'taskList':
            return markdown; // Task list container, just return the inner content
        case 'taskItem':
            const taskItemText = adfNode.attrs.state === 'DONE' ? '[x]' : '[ ]';
            return `- ${taskItemText} ${markdown}\n`;
        case 'layoutSection':
            return `\n${markdown}\n`; // Add extra line breaks around layout sections
        case 'layoutColumn':
            return `| ${markdown}`; // Separate layout columns with a vertical bar                    
        // Unsupported or unrepresentable node types in Markdown
        case 'media':
        case 'mediaGroup':
        case 'extension':
            // console.warn(`Unsupported ADF node type for Markdown: ${adfNode.type}`);
            return '';
        default:
            // console.warn(`Unknown ADF node type: ${adfNode.type}`);
            return '';
    }
}

export const processMarkdown = (adfJson: any) => {
    const markdownText = adfToMarkdown(adfJson)
    const lines = markdownText.replace(/\n\s*\n/g, '\n').split('\n');
    const sections = [];

    let currentSection: any = null;

    lines.forEach((line) => {
        const headingMatch = line.match(/^(#{1,4})\s(.+)/);

        if (headingMatch) {
            if (currentSection) {
                sections.push(currentSection);
            }
            currentSection = {
                level: headingMatch[1].length,
                title: headingMatch[2],
                content: '',
            };
        } else {
            if (currentSection) {
                currentSection.content += line + '\n';
            }
        }
    });

    if (currentSection) {
        sections.push(currentSection);
    }

    return sections
}

export function parseMarkdownSections(markdown) {
    const processor = remark().use(remarkParse);
    const tree = processor.parse(markdown);
  
    const sections = [];
    let currentSection = null;
  
    tree.children.forEach((node) => {
      if (node.type === 'heading') {
        if (currentSection) {
          sections.push(currentSection);
        }
        currentSection = {
          title: node.children.map((child) => child.value).join(' '),
          content: [],
        };
      } else if (currentSection) {
        currentSection.content.push(processor.stringify({ type: 'root', children: [node] }).trim());
      }
    });
  
    if (currentSection) {
      sections.push(currentSection);
    }
  
    return sections;
  }
  